Multithreading











Display d1 = new Display();
Display d2 = new Display();
myThread t1 = new MyThread(d1,"abc");
myThread t2 = new MyThread(d2,"def");
t1.start();
t2.start();

even though wish method is synchronised we will get irregular output
becuase threads are operating on diff java objects.
reason:
if multiple threads ar operating on same java object
then synchronisation is required
if multiple threads are operating on diff java object
then synchronisation is not required

every class in java has unique lock 
which is also known as class level lock
if a thread want to execute any static synchroniser of a class
then one lock is required by a thread
the lock required is class level lock
every object has one lock..object level lock
once method  excecution completes automatically 
thread releases the lock

while a thread executes static synchroniser method
remaining threads are not allowed.
to execute any static synchroniser method of that class simultaneously  
but remaining thread are allowed to execute the following method simultaneously

normal static method    		static func1()  //
synchroniser instance method  	syn func1()
notmal instance method			func1()

static sync func1()
static 

to tkae::::::::::  t1-t6 operating on object 


------------------
Thread Priority
------------------
valid range 1-10
min priority 1
max priority 10

it may be default whose priority is generated by jvm
it may be customized whose priority is provided by programmer
thread class defines the following constants to represent some standard priorities
which are 

Thread.MIN.PRIORITY 1
Thread.NORM_PRIORITY 5
Thread.MAX_PRIORITY 10


THREAD scheduler will use priorities while allocating the processor
the thread which is having highest priority will get chance first
if two threads having same priority then we cant expect exact execution order
it depends on thread scheduler 

Thread class defines following methods
how we can get/set priority

public final int getPriority()

public final void setPriority(int P)
allowed range of values 1-10
if out of range, then we will get runtime exception for IllegalArgumentException

default priority
for main thread it is 5

default priority 
for other remaining threads, it will get inherited from parent to child
ie whatever priority parent thread has , child thread will also share the same priority

-----------------------

 /*
  * if we are commneting line 1 then 
  * both main and child thread have same priority 5
  * hence we cant expect execution order on exact output
  * If we are not commenting line 1 
  * then main thread has a priority 5 
  * and child thread has priority 10 
  * hence child thread will get chance first 
  * followed by main thread
  * in this case output is 
  * */
some platforms wont provide proper support for thread priorities


class ChildThreads extends Thread
{
	@Override
	public void run() {
		for(int i=0;i<5;i++)
			System.out.println("child thread");
		}
}

public class ThreadPriorityProgram {
	public static void main(String[] args) {
		ChildThreads myTh = new ChildThreads();
		myTh.setPriority(10);//line 1
		myTh.start();
		
		for (int i = 0; i < 5; i++) {
			System.out.println("main thread");
		}
	}

}


-----------------------



---------------------
Inter Thread Priority
---------------------

Q.How threads communicate with each other?
	two threads can communicate with each other by using wait(),notify() and notifyAll()


two threads can communicate with each other by using wait(),notify() and notifyAll()
the thread which is expecting updation is responsible to call wait(),
Then immediately the (working or currently executing)thread will enter into waiting state.

The thread which is responsible to perform updation ,
after performing updation it is responsible to call notify(),
then waiting thread will get that notification and 
continue its execution with those updated items

Q. wait(),notify() and notifyAll()::Why these methods present in object class not in thread class
  
Ans:: If they are present in object class they can be available to threads::Not Correct
  
start method only applicable for thread..so only available in thread class
we can call join on thread object only
If object class contains any method,that method can be used on any java object
If we want to call a method on particlur object that class shud contain that method
wait , notify, notifyAll present in object class but not in thread class because
thread can call    these method on any java object 
thread can call wait on any java object
 
If a thread call wait(),notifyAll(),notifyAll() on any object 
then the thread should own the object
the thread should also have the lock of the object
the thread should be inside the synchronised area

wait(),notify() and notifyAll() should only be called from synchronised area
otherwise runtime exception saying IllegalMonitorStateException will be thrown

If a thread calls wait on any object
it immediately releases lock of particular object  
and entered into waiting state

for these 3 methods,
wait(),notify() and notifyAll()
releasing lock is important
if a thread calls notify method on any object it releases the lock of that object but may not immediately
except wait,notify.notifyAll there is no other method where thread releases  the lock

method    is lock released?
yield			no
join			no
sleep			no
wait			yes
notify			yes
notifyAll		yes

which of the following s=is valid
if a thread calls wait method immediately it will enter into waiting state without releasing any lock...invalid
if a thread calls wait method it releases the lock of the object but may not immediately...........invalid
if a thread calls wait method on any object it releases all locks acquired by the thread  and immediately entered into state...invalid
if a thread calls wait method on any object it immediately releases the lock of that particlur object and entered into waiting state...valid 
if a thread calls notify method on any object it immediately releases the lock of that particular object..invalid
if a thread calls notify method on any object it releases the lock of that object but may not immediately....

public final void wait()  
public final native void wait(long )
public final void wait(long, int )
public final native void notify( )
public final native void notifyAll()

every wait method throws InterupptedException which is checked exception
hence whenever we are using wait method compulsorily we should enter this interrupted exception
either by try catch or by throws keyword
otherwise we will get compile time error

if waiting thread got notification then where it should got
it should not go to f


:::  Prevent Thread Execution :::
yield()
join()
sleep()
We can prevent thread execution by using above following method

---------
yield()
---------
purpose::
  
 yield n join diff, yield n sleep
  
yield causes to pass current executing thread to give the transfer for waiting threads of same prioritty
if there is no waiting thread or all waiting threads have low priority
then same thread can continue its execution 
if multiple threads are waiting with same priority then which waiting thread will get the chance
we cant expect it depends on thread scheduler
the thread which is yielded when it will get chance again depends on thread scheduler
and we cannot predict this event exactly


              t.start()			                      If ThreadScheduler
a obj = new a                                         allocates processor          If run() method completes            			 
new/born---------------------------> ready/runnable  -------------------> Running -------------------------->Complete


class mythread extends thread{
public void run(){
for(int i=0;i<10;i++){
sopln("child thread");
Thread.yield();//line 1
}}}

class ThreadYield{
p s v m {
mythread th = new mythread();
th.start();
for(int i=0;i<10;i++)
sopln("main thread");


if line1 is not commented then child method always calls 
yield bcos of that main thread will get chance more than child 
and chance of completing main thread first is high

if line1 is commented we cannot expect which thread will complete first

some platforms does not provide proper support for yield

-----------
join()
-----------

if a thread wants to wait until completing some other thread then we should go for join method
if a thread t1 wants to wait until completing t2 then t1 has to call t2.join
if t1 executes t2.join then immediately t1 will be entered into waiting until t2 completes 
once t2 completes then t1 can continue its execution 

--------------------------
example: 
venue fixing
this thread t1

wedding card printing:
this thread t2 has to wait until venue fixing thread t1 completion
hence t2 has to call t1.join 



wedding card distribution
this thread t3 has to wait until wedding card printing thread t2 completion
hence t3 has to call t2.join

 
 public final void join()  
 public final void join(long ml)
  public final void join(long ms,int ns)   ns is for how much it will wait
  for some rnage ns is required after that it will get converted to ms,so it is used as ns
  
  every join methods throws InterupptedException which is checked exception
hence we should handle it compulsorily either by using try/catch or throws 
otherwise we will get compile time error

													waiting thread(on calling join)
													<--------------------
													
              t.start()			                      If ThreadScheduler
a obj = new a                                         allocates processor          If run() method completes            			 
new/born---------------------------> ready/runnable  -------------------> Running -------------------------->Complete









---------------
deadlock()
---------------
if two threads are waiting for each other forever 
such type of infinite waiting is called deadlock
synchronised keyword is responsible for making program into deadlock
while using the keyword we have to take special care
if there is deadlock there is nothing we can do we can only do prevention
there are no resolution techniques
  

https://dzone.com/articles/how-to-avoid-deadlock-in-java-threads-1

example

public void method1() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
    public void method2() {
        synchronized (Integer.class) {
            System.out.println("Aquired lock on Integer.class object");
            synchronized (String.class) {
                System.out.println("Aquired lock on String.class object");
            }
        }
    }
}



------------------
sy
------------------
only applied on method n block
not applied on class and variable
avoids data inconsistincy problem
increases waiting time of threads
hence creates performance problem
So it is not recommended to use unless there is some specefic requirement

Internally synchronisation is implemented by using lock
every object in java has a unique lock
whenever we are using synchronizer keyword then only lock cocnept will come into the pic
If a thread wants to execute a synchronizer method  on the given object 
first it has to get lock of that object
once thread got the lock then it is allowed to execute any synchriniser method on that object
once method execution completes automatically thread releases lock

Acquiring and releasinf lock internally taken care by JVM
progrmer not responsible for this activity
while a thread 
remaining threads allowed to execute non synchriniser method simultaneously
class x 
sync m1
sync m2
m3 
t1 came to execute m1 method
if t2 come to execute same m1 then waiting state
if t3 came to execute m2 method then waiting state
t4 came to execute m3 then valid

lock is implemented based on object not on method

object has 2 parts
synchronised area
can be accesssed by any no of threads simultaneously

non synchronised area
these area can be accessible by only one thead at a time

when we do add , remove, delete , replace 
ie where state of object changing
this is synchronised area

when we do read
ie where state of object not changing
this is non synchronised area

if we wish 